**AXI Protocol TL;DR**
---

```markdown
# ğŸ§  AXI Protocol â€“ TL;DR Summary

## ğŸ”¹ Structure
- Point-to-point specification  
- **5 independent unidirectional channels:**
  - `AW` â€“ Address Write â†’
  - `W` â€“ Write Data â†’
  - `B` â€“ Write Response â†
  - `AR` â€“ Address Read â†’
  - `R` â€“ Read Data â†
- Each channel uses `VALID` / `READY` handshake  

---

## âš™ï¸ Key Features
- Separate **Read** and **Write** paths â†’ Full duplex, higher bandwidth  
- **Multiple outstanding transactions** via IDs (parallel threads)  
- No timing relation between address and data  
- **Burst transfers:** single address, slave auto-calculates next  
- **Unaligned transfers** (no data loss)  
- **Out-of-order completion** across IDs allowed  

---

## ğŸ” Handshake Basics
- `VALID` â†’ from source, must stay high until accepted  
- `READY` â†’ from destination, can assert anytime  
- One `VALID`â€“`READY` handshake = **one transfer**

---

## ğŸ§® Transfer vs Transaction
- **Transfer:** One beat (single handshake)  
- **Transaction:** Complete read or write burst  

---

## âœï¸ Write Transaction
- `WLAST` = last data beat  
- Slave can detect end using `SIZE` and `LENGTH`  
- One `BRESP` for entire burst  
- Errors reported only after burst completion  

---

## ğŸ“– Read Transaction
- `RRESP` for each beat (no separate response channel)  
- Burst must complete (no early termination)  

---

## ğŸ§¾ Active / Outstanding Transactions
- **Read:** `AR` sent but last `RDATA` not yet received  
- **Write:** `AW` sent but `BRESP` not yet received  
- **Note:**  
  - Read address must come before data  
  - Write data may lead or follow address  

---

## ğŸ”„ AXI3 vs AXI4

| Feature | AXI3 | AXI4 |
|----------|------|------|
| Burst length | `AxLEN[3:0]` (16 beats) | `AxLEN[7:0]` (256 beats) |
| Lock type | `AxLOCK[1:0]` | Single-bit exclusive access |
| Write ID | `WID` present (data interleaving allowed) | `WID` removed (no interleaving) |
| Extra signals | â€” | `AWQOS`, `AWREGION`, `AWUSER`, `WUSER`, `BUSER` |

---

## ğŸ›¡ï¸ Protection Bits â€“ `AxPROT[2:0]`
| Bit | Meaning |
|-----|----------|
| 0 | Instruction/Data (0 = data) |
| 1 | Secure/Non-secure |
| 2 | Privilege/User |

---

## ğŸ’¾ Cache Control
- **Read Allocate:** Cache read miss â†’ allocate line  
- **Write Allocate:** Cache write miss â†’ allocate line  
- If disabled â†’ always access main memory  

---

## ğŸ§± Response Codes
| Code | Meaning |
|------|----------|
| 00 | OKAY / Exclusive fail |
| 01 | EXOKAY |
| 10 | SLVERR (invalid access, size mismatch, read-only write) |
| 11 | DECERR (invalid address) |

---

## ğŸ”’ Atomic Access (AxLOCK)
### Locked Access
- Channel locked until unlocked by same master  
### Exclusive Access
- Ensures read-modify-write safety between masters  
- Example:  
  - M1 ex-read @0x04 â†’ M1 ex-write â†’ **EXOKAY** (success)  
  - If M2 writes between â†’ M1 ex-write â†’ **OKAY** (fail)

---

## ğŸš¦ QoS â€“ `AxQOS`
- Priority hint for masters  
- `0x0` = lowest, `0xF` = highest  

---

## ğŸ“¤ Channel Dependencies
- `WLAST` must complete before `BVALID`  
- AXI3: response can appear before address  
- AXI4: all address/data must complete before response  
- `RVALID` only after `ARADDR` transfer  
- `WVALID` can assert before `AWVALID`

---

## ğŸ§© Ordering & IDs
- All transfers in a txn â†’ **same ID**  
- Master can issue **multiple IDs** â†’ multiple threads  

### Write Ordering (No Interleaving in AXI4)
- Data must follow address order:  
  `A0A1AL â†’ B0B1BL` âœ…  
  `A0B0B1A1ALBL` âŒ  
- Responses can complete **out-of-order** across IDs  
```

(A0A1AL, ID0) (B0B1BL, ID1)
BRESP: B(ID1) â†’ A(ID0)

```
- Same ID â†’ must complete in order  

### Read Ordering (Interleaving Allowed)
- RDATA of different IDs can be interleaved freely  
```

(B0,ID1) (A0,ID0) (B1,ID1) (A1,ID0)

```
- Same ID â†’ data must be in order  

---

## ğŸ“ Unaligned Transfers
- Only first transfer affected by alignment  
- Example:  
```

AWADDR = 1, AWSIZE = 2, AWLEN = 5
Total = 4B * 5 = 20B â†’ first byte masked by WSTRB

```

---

## ğŸ“¦ 4KB Boundary Rule
Each slave gets 4KB address space.  
Transaction must not cross 4KB boundary.

**Constraint:**  
```

(AWADDR % 4096) + (2^AWSIZE * (AWLEN + 1)) â‰¤ 4096

```

---

## ğŸ“ Address Calculations
**End Address:**  
```

AWADDR + 2^AWSIZE * (AWLEN - 1)

```

**Wrap Boundary:**  
```

int(start_addr / total_transfer) * total_transfer

```

**Wrap Example:**  
```

AWADDR = 4, AWSIZE = 2, AWLEN = 3
â†’ wrap boundary = 0, end = 16

```

---

## ğŸ”¢ Strobe (WSTRB)
- Bits = data_width / 8  
- `#ones = 2^AWSIZE`  
- Examples:  
  - size=0 â†’ 1 byte  
  - size=1 â†’ 2 bytes  
  - size=2 â†’ 4 bytes  

---

## ğŸ§  Concept Links
- **Interleaving** â†’ W/R channel data ordering  
- **Out-of-order** â†’ B/R response completion  

---
```

---
